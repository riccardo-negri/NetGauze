name: CI

on:
  push:
    branches: [ "main" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "main" ]
  schedule: [ cron: "40 1 * * *" ]

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  RUSTFLAGS: -Dwarnings

jobs:
  fmt:
    runs-on: ubuntu-latest
    name: stable / fmt
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install stable
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
      - name: cargo fmt --check
        run: cargo fmt --check

  build:
    runs-on: ubuntu-latest
    name: stable / build
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install stable
        uses: dtolnay/rust-toolchain@stable
      - name: cargo build
        run: cargo build

  test:
    name: Rust ${{matrix.rust}}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # TODO: enable msrv checks once NetGauze is more stable
        rust: [ nightly, beta, stable ]
    timeout-minutes: 45
    env:
      TRYBUILD: overwrite
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{matrix.rust}}
      - name: Enable type layout randomization
        run: echo RUSTFLAGS=${RUSTFLAGS}\ -Zrandomize-layout >> $GITHUB_ENV
        if: matrix.rust == 'nightly'
      - run: cargo test --features iana-upstream-build

  macos:
    name: macOS
    runs-on: macos-latest
    timeout-minutes: 45
    env:
      TRYBUILD: overwrite
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@nightly
      - name: Enable type layout randomization
        run: echo RUSTFLAGS=${RUSTFLAGS}\ -Zrandomize-layout >> $GITHUB_ENV
      - name: run tests
        run: C_INCLUDE_PATH=$C_INCLUDE_PATH:$HOMEBREW_PREFIX/include cargo test

  # TODO: Windows build is not working
  # windows:
  #   name: Windows
  #   runs-on: windows-latest
  #   timeout-minutes: 45
  #   env:
  #     TRYBUILD: overwrite
  #   steps:
  #     - uses: actions/checkout@v4
  #     - uses: dtolnay/rust-toolchain@nightly
  #     - name: Install pcre2
  #       run: vcpkg install pcre2
  #     - name: Install dlfcn-win32
  #       run:  vcpkg install dlfcn-win32
  #     - name: Enable type layout randomization
  #       run: echo RUSTFLAGS=${RUSTFLAGS}\ -Zrandomize-layout >> $GITHUB_ENV
  #     - name: run tests
  #       run: cargo test

  # TODO: enable min version checks once NetGauze is more stable
  #  minimal:
  #    name: Minimal versions
  #    runs-on: ubuntu-latest
  #    timeout-minutes: 45
  #    env:
  #      TRYBUILD: overwrite
  #    steps:
  #      - uses: actions/checkout@v4
  #      - uses: dtolnay/rust-toolchain@nightly
  #      - run: cargo generate-lockfile -Z minimal-versions
  #      - run: cargo check --locked

  doc:
    name: Documentation
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      RUSTDOCFLAGS: -Dwarnings --cfg docsrs
      TRYBUILD: overwrite
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@nightly
      - uses: dtolnay/install@cargo-docs-rs
      - run: cargo doc --no-deps --all-features

  clippy:
    name: Clippy
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@clippy
        with:
          toolchain: beta
      - run: cargo clippy --tests -- -Dclippy::all -A clippy::too-long-first-doc-paragraph

  coverage:
    # use llvm-cov to build and collect coverage and outputs in a format that is compatible with
    # codecov.io
    runs-on: ubuntu-latest
    name: ubuntu / stable / coverage
    env:
      TRYBUILD: overwrite
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install stable
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
      - name: cargo install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov
      - name: cargo generate-lockfile
        if: hashFiles('Cargo.lock') == ''
        run: cargo generate-lockfile
      - name: cargo llvm-cov
        run: cargo llvm-cov --locked --all-features --lcov --output-path lcov.info
      - name: Upload to codecov.io
        uses: codecov/codecov-action@v5
        with:
          fail_ci_if_error: true
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  # Define version and release information for use across jobs
  #
  # The package versioning follows the Fedora Packaging Guidelines, with a custom
  # scheme to support development builds from the main branch.
  # ref: https://docs.fedoraproject.org/en-US/packaging-guidelines/Versioning/
  #
  # The format is: <name>-<version>-<release>.<arch>.rpm
  #
  # Versioning Scheme:
  #
  # 1. Tagged Releases (e.g., refs/tags/v0.7.0):
  #    - Version: The git tag without the 'v' prefix (e.g., 0.7.0).
  #    - Release: '1'.
  #    - Example: netgauze-collector-0.7.0-1.el8_10.x86_64.rpm
  #
  # 2. Development Builds (non-tagged commits on main):
  #    - These are for testing the latest changes on the main branch.
  #    - Version: Based on the latest git tag (e.g., 0.7.0).
  #    - Release: A preview identifier in the format '0.<commits_since_tag>^<date><short_sha>'.
  #    - Example: netgauze-collector-0.7.0-0.1^20250822a3c6d71b.el8_10.x86_64.rpm
  version:
    runs-on: ubuntu-latest
    name: Calculate version information
    outputs:
      version: ${{ steps.version_and_release.outputs.VERSION }}
      release: ${{ steps.version_and_release.outputs.RELEASE }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # needs the full git history to get tag information
      - name: Define version and release
        id: version_and_release
        run: |
          TAG=$(git describe --tags --abbrev=0)
          VERSION=${TAG#v}
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            RELEASE="1"
          else
            COMMIT_COUNT=$(git describe --tags | cut -d'-' -f2)
            RELEASE="0.${COMMIT_COUNT}^$(date +%Y%m%d)$(git rev-parse --short=8 HEAD)"
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "RELEASE=${RELEASE}" >> $GITHUB_OUTPUT

  # Build RPM packages for different distributions
  build-rpm:
    runs-on: ubuntu-latest
    needs: version
    strategy:
      matrix:
        include:
          - name: "EL 8.10"
            image: "rockylinux/rockylinux:8.10"
            el_tag: "el8_10"
            arch: "x86_64"
    name: Build RPM for ${{ matrix.name }}
    container:
      image: ${{ matrix.image }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # needs the full git history to get tag information
      - name: Install build dependencies
        run: |
          dnf install -y \
            gcc \
            gcc-c++ \
            pcre2-devel \
            perl-core \
            cmake \
            git \
      - name: Install stable
        uses: dtolnay/rust-toolchain@stable
      - name: Install cargo-generate-rpm
        run: cargo install cargo-generate-rpm
      - name: Build netgauze-collector
        run: cargo build --release -p netgauze-collector
      - name: Strip netgauze-collector binary
        run: strip target/release/netgauze-collector
      - name: Build RPM package
        run: |
          cargo generate-rpm -p crates/collector -s "version = \"${{ needs.version.outputs.version }}\"" -s "release = \"${{ needs.version.outputs.release }}.${{ matrix.el_tag }}\""
      - name: Get RPM filename
        id: rpm_filename
        run: |
          RPM_PATH=$(find target/generate-rpm -name "*.rpm")
          echo "name=$(basename "$RPM_PATH")" >> $GITHUB_OUTPUT
      - name: Upload RPM artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.rpm_filename.outputs.name }}
          path: target/generate-rpm/*.rpm
          retention-days: 30

  # Build pcap-decoder binary
  #
  # More about targets: https://doc.rust-lang.org/cargo/appendix/glossary.html#target
  # Available GitHub Actions runner images  https://github.com/actions/runner-images
  build-pcap-decoder:
    runs-on: ${{ matrix.os }}
    needs: version
    name: Build pcap-decoder binary (${{ matrix.target }})
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            binary_name: netgauze-pcap-decoder
            strip_command: strip
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            binary_name: netgauze-pcap-decoder.exe
            strip_command: echo "No strip on Windows"
          - os: macos-latest
            target: x86_64-apple-darwin
            binary_name: netgauze-pcap-decoder
            strip_command: strip
          - os: macos-latest
            target: aarch64-apple-darwin
            binary_name: netgauze-pcap-decoder
            strip_command: strip
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install stable Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      - name: Build pcap-decoder
        run: cargo build --release --target ${{ matrix.target }} -p netgauze-pcap-decoder
      - name: Strip binary (Unix only)
        if: matrix.os != 'windows-latest'
        run: ${{ matrix.strip_command }} target/${{ matrix.target }}/release/${{ matrix.binary_name }}
      - name: Create complete binary file name
        id: binary_filename
        run: |
          echo "name=netgauze-pcap-decoder-${{ needs.version.outputs.version }}-${{ needs.version.outputs.release }}-${{ matrix.target }}${{ matrix.binary_name == 'netgauze-pcap-decoder.exe' && '.exe' || '' }}" >> $GITHUB_OUTPUT
      - name: Rename binary
        run: mv target/${{ matrix.target }}/release/${{ matrix.binary_name }} target/${{ matrix.target }}/release/${{ steps.binary_filename.outputs.name }}
      - name: Upload pcap-decoder artifact
        uses: actions/upload-artifact@v4
        with:
          # name it with the same convetion as the RPMs
          name: ${{ steps.binary_filename.outputs.name }}
          path: target/${{ matrix.target }}/release/${{ steps.binary_filename.outputs.name }}
          retention-days: 30

  # Upload release artifacts to already existent GitHub releases
  upload-release-artifacts:
    runs-on: ubuntu-latest
    name: Upload release artifacts
    needs: [build-rpm, build-pcap-decoder]
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: netgauze-*
          merge-multiple: true
      - name: Upload artifacts to release
        uses: softprops/action-gh-release@v2
        with:
          files: ./artifacts/*
          tag_name: ${{ github.ref_name }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish crates to crates.io
  publish-crates:
    runs-on: ubuntu-latest
    name: Publish crates to crates.io ${{ startsWith(github.ref, 'refs/tags/v') && ' (release)' || ' (dry-run)' }}
    # run after all tests pass and build jobs complete successfully
    needs: [fmt, build, test, macos, clippy, build-rpm, build-pcap-decoder]
    steps:
      - uses: actions/checkout@v4
      - name: Install stable
        uses: dtolnay/rust-toolchain@stable
      - name: Publish crates
        uses: katyo/publish-crates@v2
        with:
          registry-token: ${{ secrets.CARGO_REGISTRY_TOKEN }}
          dry-run: ${{ !startsWith(github.ref, 'refs/tags/v') }}
          # only check for tagged releases, in other cases we have code changes and no new version
          check-repo: ${{ startsWith(github.ref, 'refs/tags/v') }}
          ignore-unpublished-changes: ${{ !startsWith(github.ref, 'refs/tags/v') }}
